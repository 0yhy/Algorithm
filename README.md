[TOC]



# Algorithm

## 排序算法

### 排序算法的分类

#### 按不同原则分类

* 插入排序
  * 直接插入排序
  * 希尔排序
* 选择排序
  * 简单选择排序
  * 堆排序
* 交换排序
  * 冒泡排序
  * 快速排序
* 归并排序
* 基数排序

#### 按时间复杂度分类

* 比较排序：$O(N^2)$
  
  > 每个数需比较$n$次；规模为$n$
  
* 优化的比较排序：$O(NlogN)$

  > 每个数需比较$n$次；规模通过分治优化为$logN$次

  * 归并排序
  * 快速排序

* 非比较排序：$O(N)$

  > 确定每个元素之前的已有的元素个数即可，一次遍历即可解决

  * 桶排序
  * 基数排序
  * 计数排序

### 冒泡排序 Bubble Sort

#### 算法描述

* 比较相邻的两个元素，若为逆序，则交换位置

* 从前往后（后往前）两两比较，使第一个最大/小数归位。

  该过程称为一趟冒泡排序

* 重复上述过程，使第二、三...个最大/小数归位

* 结束条件：在一趟冒泡排序中没有进行过交换的操作

#### 时间复杂度

* 最好情况：$O(N)$
* 最坏情况：$O(N^2)$
* 平均情况：$O(N^2)$



### 快速排序 Quick Sort

#### 算法描述

通过一趟排序将待排记录分成独立的两部分，其中一部分数据均小于另一部分数据，分别再对这两部分记录继续进行排序

* 从数列中取出一个元素，称为**枢轴**(pivot)

* 将所有比这个数小的数放在它的左边；所有大于等于它的数放在它的右边。

  该过程称为一趟快速排序（Partition）

* 对左右两列重复上述步骤

* 结束条件：各个区间只剩下一个数

#### 时间复杂度

* 最好情况：$O(NlogN)$
* 最坏情况：$ O(N^2)$
* 最好情况：$O(NlogN)$



### 归并排序 Merge Sort

#### 算法描述

性能不受输入数据的影响，是一种稳定的排序算法；需要**额外的空间**

* 将长度为n的序列看作$n$个长度为1的子序列，两两归并
* 将上述得到的$\lceil n/2 \rceil$个子序列两两归并
* 如此重复，直至得到长度为$n$的有序序列

#### 时间复杂度

始终为$O(NlogN)$



## 最短路径
> 最短路径的核心思想就是能否通过第三点来改变另外两点之间的最短距离
### Floyd
遍历每一个点，判断在经过该点中转的情况下能否使两点间的路径变短
* 多源最短路径
* 邻接矩阵存图 
* $O(N^3)$ 
* 无法解决负权回路

### Dijkstra
每次选出离start最近的点，此时该点与start的距离已由“估计值”变为了“确定值”。然后对该点的出边进行松弛操作。其本质思想是**贪心**
* 单源最短路径
* 邻接表存图
* $O(N^2)$
* 不能含有负权边
> 为什么不能含有负权边？因为Dijkstra的条件是每次找出距离start最近的点，其他边权都为正时，该点的dist就不会再因为别的边而发生变化。含有负权时则打破了这条规则。

**堆优化：** 每次查找距离源点最近的点时可用堆来优化：用$O(logN)$的时间取出栈顶元素并删除，用$O(logN)$遍历每条边。时间复杂度可降到$O((M+N)logN)$

## 树
### 二叉搜索树
对于任意一个节点`x`，其左子树中的关键字最大不超过`x.data`，其右子树中的关键字最小不小于`x.data`
* 前序遍历
* 中序遍历
* 后序遍历

### 堆

## 字符串
### Manacher

马拉车算法 **Manacher's Algorithm** 是用来**查找一个字符串的最长回文子串**的**线性**方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。
1. **奇偶问题填充解决**
    对于奇偶字符串的处理，Manacher采用的是字符之间填充相同符号、字符串两端都加入不同字符的方法
    
    如字符串`“abbccbba”`，增加字符后变成`“@#a#b#b#c#c#b#b#a#0”`
    
    这样处理后，原来的字符串无论奇偶，都将变成奇字符串来处理。
    
2. **重定义字符串长度**
   字符串长度由`n`变为了`2 * n + 2`

3. **原字符串下标**

   ```
   $0#1#2#3#4@
   $a#b#c#b#a@
   0123456789
   ```

   显然，`原坐标 = （现坐标 - 1) / 2`

4. **计算最长回文子串长度**

     用`p[i]`表示以`s[i]`字符为中心的最长回文半径

     



